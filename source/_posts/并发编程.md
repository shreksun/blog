---
title: 并发编程
date: 2019-03-12 20:40:00
tags:
categories:
- Java
---

#### 对象共享

* 加锁不仅是互斥行为，还保证了内存的可见性。为了所有线程都能看到共享变量的最新值，执行这个值的读写操作必须保持同一个锁。
* volatile
  * 变量不会被缓存，被标记的变量读取时保证最新值。比加锁轻的同步。
  * 使用在需要确保它们自身状态的可见性的地方,标记重要的程序生命周期。
  * 不保证原子性，只保证可见性。

<!--more-->

```java
volatile boolean asleep

while(asleep)

countSomeSheep()


```

##### 发布逸出

* 一个对象可以在当前作用域以外被实现。

##### 线程封闭

* volatile线程封闭只要保证单线程写，则可以保证线程封闭，volatile保证读最新。
* ThreadLocal
  * 保证使用的变量每个线程保存一个副本。
  * 增加隐含耦合，降低可重用性，小心使用。

##### 不变性

* final 可以创建一个不可变对象，来保证原子性。

##### 安全发布

* 最方便的发布静态构造对象，使用静态的初始化器。由jvm保证安全发布
* 不可变对象可以任意机制发布。
* 事实不可变对象需要安全方式发布。（把引用放入final，静态，放入线程安全容器）
* 可变对象要安全方式发布，并且加锁。

##### 在线程安全类扩展功能

* 通过继承的方式扩展功能，必须保证父类同步策略，锁不改变，否则会破坏子类的线程安全。
* 扩展时采用客户端加锁必须保证锁一致。
* 客户端加锁，扩展类方式都会破环封装性。
* 组合方式，实现需要扩展的操作，并加锁，讲原有操作同步，委托给原有类。更为健壮，不受需要扩展类的同步策略变化。

#### 基础构建模块

##### 同步容器类

* 迭代器在容器被修改时会抛出concurrentModificationException
* 使用迭代器也无法避免遍历是的同步问题，需要加锁
* ConcurrentHashMap迭代过程中不需要加锁，弱一致性，size，isEmpty不准确，增强了性能，只有需要对map进行独占访问时才需要使用Hashtable，synchrnziedMap
* CopyOnWriteArrayList用于替代同步List，写入时复制，只有当迭代数量远大于修改数量时适合使用。





